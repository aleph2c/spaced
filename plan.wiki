*Space Repetition Algorithm*

= Observe =
  
  *What defines Success?*
  
  The schedule generation is done using a Python generator.  The range uses the
  generator to create a limited schedule which can be graphed.
  
  *What is the problem?*
  
  The schedule really needs to run forever, not just over the range provided by
  the user.  The range will cause the tracker to stop when it shouldn't stop,
  since the maintenance pulses need to go on and on and on.
  
  The range argument given to a learning tracker came from the need to draw a
  graph, so that I could see if the algorithm was working.
  
  The range can still be an argument, but the schedule should go on forever.
  
  Python has a language feature for these kinds of problems, it is called a
  generator.  The range needs to use a generator, and the graphs should look the
  same, but the learning tracker and it's inner parts should be able to
  provide infinite schedules.
  
    
  *Evidence that contradicts Assumptions:*
  
= Orient =
  *Symptoms:*
  
  *Questions for Space Repetition Algorithm:*
  
  * Is there another way to do this?
  * Maybe a schedule doesn't need to run forever, maybe it would be a good thing
    for a learning tracker to delete itself from the system
  * Could you create an 'ignored' or 'hold' state for the learning tracker, so
    it does not end up clogging the system?

  *Assumptions:*

= Decide =
  *Idea/Hypotheses for Space Repetition Algorithm: >=5*
  * [ ] Keep the interface simple, the client will add complexity if it needs
        to.  Have the schedule run forever using a generator, then use the range
        argument for graphing.  In doing so move the range argument out of main
        constructor and into the graph plotting methods.
  * [ ] The learning tracker should be run for a pre-set number of times, then
        die.  It should report if the learning intervention worked or not up to
        its client.
  * [ ] The tracker can go into stasis if the idea being uses is integrating
        into another idea being tracked
  * [ ] The tracker can delete itself if the idea being uses is integrating
        into another idea being tracked
  * [ ] Keeping a learning tracker in memory, when it is subsumed by another
        learning tracker is wasteful.  So, we will have the option of running
        forever (say for chinese character learning), but also have the option
        to put it on ice (mathematical concept that is foundational).
  * [ ] The learning trackers can know about one another, so that they can build
        a Dag or statechart.
  
        
  *Chosen Idea/Hypothesis*
    
    Keep the interface simple, the client will add complexity if it is needed.
    Have the schedule run forever using a generator, then use the range argument
    for graphing.  In doing so, move the range argument out of the main
    constructor and into the graphing plot methods.
    
    Provide an option to put the learning tracker on ice, in the case its idea
    is being subsumed by another more complicated idea that is being tracked by
    a different learning tracker.

  *Plan to Expand-on-Idea/Disprove-Hypothesis*
  * [X] Read up on generators, write some practice code.
  * [ ] Get your tests in a state where you can see if you have broken the
        functionality of the system.
  * [X] Update your Jupyter notebooks so you can see if the queries are working
        visually.
  * [X] Check in the tests and the plan
  * [X] Branch the code so it is easy to do diffs in the case that you break
        things.
  * [X] Analyze the existing code.  I think most of this work can happen in the
        reference class, or at least this is where things are hard.
        * write ideas as comments in the code
        * use Gvdiff to view your notes
        * write a general strategy (what)
        * write a set of tactics (how)
        * investigate sympy?
  * [ ] Simplify and document the code internally, change the structure so it
        will be easier to apply a generator
  * [ ] Create a simplified example of what you want to do in the experiment
        folder.
  * [ ] Perform the surgery
  * [ ] Re-run tests
  * [ ] Run Jupyter notebooks to see what has changed
  * [ ] Iterate on this OODA loop if required
  * [ ] Write new tests if it makes sense to.
  * [ ] Update the docs with the API changes.
  * [ ] merge with master
  * [ ] push to github
  * [ ] release pip package

= Act =

